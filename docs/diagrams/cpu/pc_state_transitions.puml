@startuml pc_state_transitions
!theme plain
title MSP430 Program Counter (PC/R0) State Transitions

scale 900 width

state "Reset" as RESET {
    state "PC = 0x0000" as PC_RESET : Power-up state\nPC cleared to 0x0000
}

state "Normal Execution" as NORMAL {
    state "Fetch" as FETCH : PC points to instruction\nRead instruction from memory
    state "Decode" as DECODE : PC incremented by 2\nInstruction decoded
    state "Execute" as EXECUTE : Execute instruction\nMay modify PC
    
    FETCH --> DECODE : Increment PC (+2)
    DECODE --> EXECUTE : Instruction ready
    EXECUTE --> FETCH : Next instruction
}

state "Branch/Jump Operations" as BRANCH {
    state "Conditional Branch" as COND_BRANCH : Branch if condition met\nPC = PC + offset
    state "Unconditional Jump" as UNCOND_JUMP : Always jump\nPC = new address
    state "Call Subroutine" as CALL : Push PC to stack\nPC = subroutine address
    state "Return" as RETURN : Pop PC from stack\nRestore saved PC
}

state "Interrupt Handling" as INTERRUPT {
    state "Interrupt Request" as IRQ : Interrupt pending\nGIE flag checked
    state "Vector Fetch" as VECTOR : Read interrupt vector\nPC = vector address
    state "ISR Execution" as ISR : Execute interrupt handler\nPC in ISR code
    state "Return from Interrupt" as RETI : Restore PC and SR\nReturn to interrupted code
}

state "Special Operations" as SPECIAL {
    state "Stack Operations" as STACK : PUSH/POP instructions\nMay affect PC indirectly
    state "Register Operations" as REG_OPS : Direct PC modification\nMOV #value, PC
    state "Address Calculation" as ADDR_CALC : PC-relative addressing\nPC + offset calculations
}

' State transitions
RESET --> NORMAL : System startup\nBegin execution

NORMAL --> BRANCH : Branch/Jump instruction\nConditional or unconditional

BRANCH --> NORMAL : Branch completed\nContinue execution

NORMAL --> INTERRUPT : Interrupt occurs\nGIE = 1, interrupt pending

INTERRUPT --> NORMAL : Return from interrupt\nRETI instruction

NORMAL --> SPECIAL : Special instruction\nDirect PC manipulation

SPECIAL --> NORMAL : Operation complete\nContinue normal flow

' PC Alignment Rules
note right of NORMAL : PC Alignment Rules:\n• Always word-aligned (even addresses)\n• Odd addresses automatically rounded down\n• Instruction fetch increments by 2

note left of BRANCH : Branch Target Rules:\n• Branch offset is word-aligned\n• Jump targets must be even addresses\n• Invalid addresses cause undefined behavior

note bottom of INTERRUPT : Interrupt Vector Rules:\n• Vectors stored in high memory (0xFFE0-0xFFFF)\n• Each vector is 2 bytes (word-aligned)\n• Hardware automatically pushes PC and SR

note top of SPECIAL : PC Modification Rules:\n• Direct writes to R0 affect PC\n• Stack operations may indirectly affect PC\n• Address calculations preserve alignment

' Error conditions
state "Error Conditions" as ERROR {
    state "Invalid Address" as INVALID : PC points to invalid memory\nAccess violation
    state "Misaligned Access" as MISALIGN : PC has odd value\nAutomatic alignment
    state "Stack Overflow" as STACK_ERR : Stack pointer corruption\nPC restoration fails
}

NORMAL --> ERROR : Error condition detected
BRANCH --> ERROR : Invalid branch target
INTERRUPT --> ERROR : Vector table corruption
SPECIAL --> ERROR : Invalid PC value

ERROR --> RESET : System reset required\nRecovery action

' Legend for state types
legend bottom
    |State Type |Description |PC Behavior |
    |Reset |System initialization |PC = 0x0000 |
    |Normal |Sequential execution |PC += 2 per instruction |
    |Branch |Flow control |PC = calculated address |
    |Interrupt |Exception handling |PC = vector address |
    |Special |Direct manipulation |PC = specified value |
    |Error |Invalid conditions |Undefined behavior |
endlegend

@enduml