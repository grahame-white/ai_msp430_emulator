# 1.13 Device Descriptor Table

Each device provides a data structure in memory that allows an unambiguous identification of the device as well as a
description of the available modules on a given device. SYS provides this information and can be used by
device-adaptive software tools and libraries to clearly identify a particular device and all of its modules and
capabilities. The validity of the device descriptor can be verified by cyclic redundancy check (CRC). The CRC checksum
covers a device-specific TLV range. See the TLV table in the device-specific data sheet for the definitions.
[Figure 1-17](#figure-1-17) shows the logical order and structure of the device descriptor table. The complete device
descriptor table and its contents can be found in the device-specific data sheet.

<a id="figure-1-17"></a>

![Figure 1-17. Devices Descriptor Table](/images/fr4xx_fr2xx_family_user_guide/figure_1-17.jpg)

**Figure 1-17. Devices Descriptor Table**

## 1.13.1 Identifying Device Type

The value at address location 00FF0h identifies the family branch of the device. All values starting with 80h indicate
a hierarchical structure that consists of the information block and a tag-length-value (TLV) structure with the various
descriptors. Any value other than 80h at address location 00FF0h indicates that the device is of an older family and
contains a flat descriptor beginning at location 0FF0h. The information block, shown in [Figure 1-17](#figure-1-17)
contains the device ID, die revisions, firmware revisions, and other manufacturer and tool related information. The
descriptors contains information about the available peripherals and their subtypes and addresses and provides the
information required to build adaptive hardware drivers for operating systems.

The length of the descriptors is represented by Info_length and is computed as shown in [Equation 1](#equation-1).

<a id="equation-1"></a>

```math
\text{Length} = 2^{Info\_length} \text{ in 32-bit words}
```

**Equation 1. Descriptor Length**

For example, if Info_length = 5, then the length of the descriptors equals 128 bytes.

## 1.13.2 TLV Descriptors

The TLV descriptors follow the information block. Because the information block is always a fixed length, the start
location of the TLV descriptors is fixed for a given device family. See the device-specific data sheet for the complete
TLV structure and what descriptors are available.

The TLV descriptors are unique to their respective TLV block and are always followed by the descriptor block length.

Each TLV descriptor contains a tag field that identifies the descriptor type. [Table 1-6](#table-1-6) lists the
currently supported tags.

<a id="table-1-6"></a>

| Short Name | Value      | Description                     |
| ---------- | ---------- | ------------------------------- |
| LDTAG      | 01h        | Legacy descriptor               |
| PDTAG      | 02h        | Peripheral discovery descriptor |
| Reserved   | 03h        | Future use                      |
| Reserved   | 04h        | Future use                      |
| BLANK      | 05h        | Blank descriptor                |
| Reserved   | 06h        | Future use                      |
| ADCCAL     | 11h        | ADC calibration                 |
| REFCAL     | 12h        | REF calibration                 |
| Reserved   | 13h to FDh | Future use                      |
| TAGEXT     | FEh        | Tag extender                    |

**Table 1-6. Tag Values**

Each tag field is unique to its respective descriptor and is always followed by a length field. The length field is one
byte if the tag value is 01h through 0FDh and represents the length of the descriptor in bytes. If the tag value equals
0FEh (TAGEXT), the next byte extends the tag values, and the following two bytes represent the length of the descriptor
in bytes. In this way, a user can search through the TLV descriptor table for a particular tag value using a routine
similar to the following, which is written in pseudo code:

```c
// Identify the descriptor ID (d_ID_value) for the TLV descriptor of interest:
descriptor_address = TLV_START address;
while ( value_at_descriptor_address != d_ID_value && descriptor_address != TLV_TAGEND && descriptor_address < TLV_END)
{
  // Point to next descriptor
  descriptor_address = descriptor_address + (length of the current TLV block) + 2;
}
if (value at descriptor_address == d_ID_value) {
  // Appropriate TLV descriptor has been found!
  Return length of descriptor & descriptor_address as the location of the TLV descriptor
} else {
  // No TLV descriptor found with a matching d_ID_value
  Return a failing condition
}
```

## 1.13.3 Calibration Values

The TLV structure contains calibration values that can be used to improve the measurement capability of various
functions. The calibration values available on a given device are shown in the TLV structure of the device-specific
data sheet.

### 1.13.3.1 1.5-V Reference Calibration

The calibration data consists a word for reference voltage available (1.5 V). The reference voltages are measured at
room temperature. The measured values are normalized by 1.5 V before being stored into the TLV structure:

<a id="equation-2"></a>

```math
Factor_{gain\_1.5Vref} = \frac{V_{REF+}}{1.5V} \times 2^{15}
```

**Equation 2. Gain Calibration Factor**

In this way, a conversion result is corrected by multiplying it with the _Factor<sub>gain_1.5Vref</sub>_ and dividing
the result by 2<sup>15</sup> as shown for each of the respective reference voltages:

<a id="equation-3"></a>

```math
ADC_{calibrated} = ADC_{raw} \times Factor_{gain\_1.5Vref} \times \frac{1}{2^{15}}
```

**Equation 3. ADC Calibration**

In the following example, the integrated 1.5-V reference voltage is used during a conversion.

- Conversion result: 0x0100 = 256 decimal
- Reference voltage calibration factor (_Factor<sub>gain_1.5Vref</sub>_) : 0x7BBB

The following steps show how the ADC conversion result can be corrected:

- Multiply the conversion result by 2 (this step simplifies the final division): 0x0100 x 0x0002 = 0x0200
- Multiply the result by _Factor<sub>gain_1.5Vref</sub>_: 0x200 x 0x7BBB = 0x00F7_7600
- Divide the result by 2<sup>16</sup>: 0x00F7_7600 / 0x0001_0000 = 0x0000_00F7 = 247 decimal

### 1.13.3.2 ADC Offset and Gain Calibration

The offset of the ADC is determined and stored as a twos-complement number in the TLV structure. The offset error
correction is done by adding the _ADC<sub>offset</sub>_ to the conversion result.

<a id="equation-4"></a>

```math
ADC_{offset\_calibrated} = ADC_{raw} + ADC_{offset}
```

**Equation 4. ADC Offset Calibration**

The gain factor of the ADC is calculated by [Equation 5](#equation-5):

<a id="equation-5"></a>

```math
Factor_{gain} = \frac{1}{Gain} \times 2^{15}
```

**Equation 5. Gain Calibration Factor**

The conversion result is gain corrected by multiplying it with the _Factor<sub>gain</sub>_ and dividing the result by
2<sup>15</sup>:

<a id="equation-6"></a>

```math
ADC_{gain\_calibrated} = ADC_{raw} \times Factor_{gain} \times \frac{1}{2^{15}}
```

**Equation 6. ADC Gain Calibration**

If both gain and offset are corrected, the gain correction is done first:

<a id="equation-7"></a>

```math
ADC_{calibrated} = ADC_{raw} \times Factor_{gain} \times \frac{1}{2^{15}} + ADC_{offset}
```

**Equation 7. ADC Offset and Gain Calibration**

### 1.13.3.3 Temperature Sensor Calibration

The temperature sensor is calibrated using the internal voltage references. The 1.5V reference voltage contains a
measured value for two temperatures, room temperature (typically, the value is 30°C) and high temperature (85°C or
105°C; see the device-specific data sheet for details), which are stored in the TLV structure. The characteristic
equation of the temperature sensor voltage, in mV is:

<a id="equation-8"></a>

```math
V_{SENSE} = TC_{SENSOR} \times Temperature + V_{SENSOR}
```

**Equation 8. Temperature Sensor Equation**

The temperature coefficient, _TC<sub>SENSOR</sub>_, in mV/°C, represents the slope of the equation.
_V<sub>SENSOR</sub>_, in mV, represents the y-intercept of the equation. _Temp_, in °C, is the temperature of interest.

The temperature (_Temp_, °C) can be computed as follows for each of the reference voltages used in the ADC measurement:

<a id="equation-9"></a>

```math
Temperature = (ADC_{raw} - ADC_{30°C\_1.5V\_ref}) \times \left(\frac{55°C}{ADC_{85°C\_1.5V\_ref} - ADC_{30°C\_1.5V\_ref}}\right) + 30°C
```

**Equation 9. Temperature Sensor Calibration 85°C**

<a id="equation-10"></a>

```math
Temperature = (ADC_{raw} - ADC_{30°C\_1.5V\_ref}) \times \left(\frac{75°C}{ADC_{105°C\_1.5V\_ref} - ADC_{30°C\_1.5V\_ref}}\right) + 30°C
```

**Equation 10. Temperature Sensor Calibration 105°C**

### 1.13.3.4 DCO Calibration

The DCO calibration is stored for a quick setting to maximum DCO frequency (for example, 16 MHz) at room temperature.
Loading this value to the `CSCTL0` register significantly reduces the FLL lock time when the MCU reboot or exits from a
low-power mode. If a possible frequency overshoot caused by temperature drift is expected after exit from an LPM, TI
recommends dividing the DCO frequency before use. For more details, see
[Section 1.4.4](/fr4xx_fr2xx_family_user_guide/03_chapter_1/1.4_operating_modes.md#144-extended-time-in-low-power-modes).
