# 1.9 Memory Map â€“ Uses and Abilities

## 1.9.1 Memory Map

This memory map represents the MSP430FR2xx and MSP430FR4xx devices. Although the address ranges differ from device to
device, overall behavior remains the same.

| Address Range    | Name and Usage                        | Properties | Segment erase by user possible | Bank erase by user possible | Always able to access `PMM` registers from (1), Mass erase by user possible | Protectable for read and write accesses | Generates PUC on fetch access | Can generate NMI on read, write, or fetch |
| ---------------- | ------------------------------------- | ---------- | ------------------------------ | --------------------------- | ---------------------------------------------------------------------------- | --------------------------------------- | ----------------------------- | ----------------------------------------- |
| 00000h to 00FFFh | Peripherals with gaps                 |            |                                |                             |                                                                              |                                         |                               |                                           |
| 00000h to 000FFh | Reserved for system extension         |            |                                |                             |                                                                              |                                         |                               |                                           |
| 00100h to 00FEFh | Peripherals                           |            |                                |                             |                                                                              |                                         | x                             |                                           |
| 00FF0h to 00FF3h | Descriptor type (2)                   |            |                                |                             |                                                                              |                                         | x                             |                                           |
| 00FF4h to 00FF7h | Start address of descriptor structure |            |                                |                             |                                                                              |                                         | x                             |                                           |
| 01800h to 019FFh | Information Memory                    | x          | x                              | x                           | x                                                                            | x                                       |                               |                                           |
| 02000h to 03FFFh | RAM 8kB                               |            |                                |                             |                                                                              |                                         |                               |                                           |
| 02000h to 02FFFh | RAM 4kB                               |            |                                |                             |                                                                              |                                         |                               |                                           |
| 02000h to 027FFh | RAM 2kB                               |            |                                |                             |                                                                              |                                         |                               |                                           |
| 02000h to 023FFh | RAM 1kB                               |            |                                |                             |                                                                              |                                         |                               |                                           |
| 02000h to 021FFh | RAM 512B                              |            |                                |                             |                                                                              |                                         |                               |                                           |
| 08000h to 0FFFFh | Program 32kB                          | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0C000h to 0FFFFh | Program 16kB                          | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0C400h to 0FFFFh | Program 15kB                          | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0E000h to 0FFFFh | Program 8kB                           | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0F000h to 0FFFFh | Program 4kB                           | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0F800h to 0FFFFh | Program 2kB                           | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0FC00h to 0FFFFh | Program 1kB                           | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0FE00h to 0FFFFh | Program 512B                          | x          | x(3)                           | x                           | x                                                                            | x                                       |                               |                                           |
| 0FF80h to 0FFFFh | Interrupt Vectors                     |            |                                |                             |                                                                              |                                         |                               |                                           |

(1) Access rights are separately programmable for SYS and `PMM`.

(2) On vacant memory space, the value 03FFFh is driven on the data bus.

(3) Fixed ID for all MSP430 devices. See
[Section 1.13.1](/fr4xx_fr2xx_family_user_guide/03_chapter_1/1.13_device_description_table.md#1131-identifying-device-type)
for further details.

## 1.9.2 Vacant Memory Space

Vacant memory is nonexistent memory space. Accesses to vacant memory space generate a system (non)maskable interrupt
(SNMI), when the interrupt is enabled (`VMAIE` = 1). Reads from vacant memory result in the value 3FFFh. In the case of
a fetch, this is taken as JMP \$. Fetch accesses from vacant peripheral space result in a PUC. After the boot code is
executed, the boot code memory space behaves like vacant memory space and also causes an NMI on access.

## 1.9.3 FRAM Write Protection

FRAM write protection allows the user to prevent any unwanted write protection to FRAM contents. The SYS module offers
two separate write protection.

- User program FRAM protection always used to store user main program and constant data protected by the `PFWP` bit in
  the `SYSCFG0` register
- User data FRAM protection always fixed from 1800h to 18FFh or 19FFh (see the device-specific data sheet on info
  memory) and protected by the `DFWP` bit in the `SYSCFG0` register
- Before FRAM access, the write-protect password must be written together with the program or data FRAM protection bit;
  see the device-specific `SYSCFG0` register in
  [Section 1.16](/fr4xx_fr2xx_family_user_guide/03_chapter_1/1.16_system_configuration_registers.md) for details.

When write protection is enabled, any write access to the protected FRAM causes an invalid write operation but does not
generate an interrupt or reset. TI recommends enabling write protection at the beginning of the user initialization
routine. To write data to FRAM, write the data as soon as the write protection is disabled, and then immediately enable
write protection again when the write is complete.

> [!CAUTION]
> To protect the program stored in FRAM from unintended writes, FRAM write protection must be enabled at all times,
> except when an intentional write operation is performed. The write operation should be completed within as short a
> time as possible with interrupts disabled to reduce the risk of an unintended write operation.

## 1.9.4 Bootloader (BSL)

The bootloader (BSL) (formerly known as the bootstrap loader) is software that is executed after start-up when a
certain BSL entry condition is applied. The BSL lets the user communicate with the embedded memory in the
microcontroller during the prototyping phase, final production, and in service. All memory mapped resources, the
programmable memory (FRAM memory), the data memory (RAM), and the peripherals can be modified by the BSL as required.
The user can define custom BSL code for FRAMbased devices and protect it against erasure and unintentional or
unauthorized access.

On devices without USB, a basic BSL program is provided by TI. This supports the commonly used UART protocol with RS232
interfacing, allowing flexible use of both hardware and software. To use the BSL, a specific BSL entry sequence must be
applied to specific device pins. The correct entry sequence causes `SYSBSLIND` to be set. An added sequence of commands
initiates the desired function. A boot-loading session can be exited by continuing operation at a defined user program
address or by applying the standard reset sequence.

Access to the device memory by the BSL is protected against misuse by a user-defined password. Devices with USB have a
USB based BSL program provided by TI. For more details, see the
[MSP430 FRAM Device Bootloader (BSL) User's Guide](http://www.ti.com/lit/pdf/SLAU550).

The amount of BSL memory that is available is device specific. The BSL memory size is organized into segments. See the
device-specific data sheet for the number and size of the segments available. It is possible to assign a small amount
of RAM to the allocated BSL memory. Setting `SYSBSLR` allocates the lowest 16 bytes of RAM for the BSL. When the BSL
memory is protected, access to these RAM locations is only possible from within the protected BSL memory segments.

It may be desirable in some BSL applications to only allow changing of the Power Management Module settings from the
protected BSL segments. This is possible with the `SYSPMMPE` bit. Normally, this bit is cleared and allows access of
the `PMM` control registers from any memory location. Setting `SYSPMMPE` allows access to the `PMM` control registers
only from the protected BSL memory. After `SYSPMMPE` is set, it can only be cleared by a BOR event.
