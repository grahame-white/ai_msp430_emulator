#!/usr/bin/env bash
# scripts/defect-analysis
# Defect analysis and reporting script for MSP430 Emulator

set -e

cd "$(dirname "$0")/.."

# Configuration
GITHUB_API="https://api.github.com"
REPO_OWNER="grahame-white"
REPO_NAME="ai_msp430_emulator"
OUTPUT_DIR="./reports/defect-analysis"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

# Create output directory
mkdir -p "$OUTPUT_DIR"

# Function to analyze GitHub issues (if GITHUB_TOKEN is available)
analyze_github_issues() {
    if [[ -z "${GITHUB_TOKEN}" ]]; then
        log_warning "GITHUB_TOKEN not set. Skipping GitHub issue analysis."
        return
    fi

    log_info "Analyzing GitHub issues..."
    
    local output_file="${OUTPUT_DIR}/github_issues_$(date +%Y%m%d_%H%M%S).json"
    
    # Fetch open issues with bug label
    curl -s -H "Authorization: token $GITHUB_TOKEN" \
         -H "Accept: application/vnd.github.v3+json" \
         "${GITHUB_API}/repos/${REPO_OWNER}/${REPO_NAME}/issues?labels=bug&state=all&per_page=100" \
         > "$output_file"
    
    if [[ $? -eq 0 ]]; then
        log_success "GitHub issues data saved to $output_file"
        
        # Parse and summarize
        local total_issues=$(jq length "$output_file")
        local open_issues=$(jq '[.[] | select(.state == "open")] | length' "$output_file")
        local closed_issues=$(jq '[.[] | select(.state == "closed")] | length' "$output_file")
        
        log_info "GitHub Issues Summary:"
        echo "  Total bug reports: $total_issues"
        echo "  Open: $open_issues"
        echo "  Closed: $closed_issues"
    else
        log_error "Failed to fetch GitHub issues"
    fi
}

# Function to analyze test results
analyze_test_results() {
    log_info "Analyzing test results..."
    
    # Run tests and capture results
    local test_output="${OUTPUT_DIR}/test_results_$(date +%Y%m%d_%H%M%S).xml"
    
    if dotnet test --logger "trx;LogFileName=${test_output}" > /dev/null 2>&1; then
        log_success "Tests completed successfully"
        
        # Parse test results (simplified - would need more sophisticated XML parsing in practice)
        if [[ -f "$test_output" ]]; then
            log_info "Test results saved to $test_output"
        fi
    else
        log_error "Test execution failed"
        return 1
    fi
}

# Function to analyze code quality metrics
analyze_code_quality() {
    log_info "Analyzing code quality..."
    
    local quality_report="${OUTPUT_DIR}/code_quality_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "Code Quality Analysis Report"
        echo "Generated: $(date)"
        echo "=================================="
        echo
        
        # Run static analysis
        echo "Static Analysis Results:"
        echo "------------------------"
        if dotnet build --verbosity quiet 2>&1 | grep -E "(warning|error)" || echo "No warnings or errors found"; then
            echo
        fi
        
        # Count files and lines
        echo "Code Metrics:"
        echo "-------------"
        echo "C# files: $(find src -name "*.cs" | wc -l)"
        echo "Test files: $(find tests -name "*.cs" | wc -l)"
        echo "Total lines of code: $(find src -name "*.cs" -exec wc -l {} + | tail -1 | awk '{print $1}')"
        echo "Total lines of tests: $(find tests -name "*.cs" -exec wc -l {} + | tail -1 | awk '{print $1}')"
        echo
        
        # Analyze defect-related code
        echo "Defect Management Code Analysis:"
        echo "--------------------------------"
        local defect_files=$(find src -path "*/Quality/*" -name "*.cs" | wc -l)
        local defect_test_files=$(find tests -path "*/Quality/*" -name "*.cs" | wc -l)
        echo "Defect management files: $defect_files"
        echo "Defect management test files: $defect_test_files"
        
        if [[ $defect_files -gt 0 ]]; then
            echo "Defect management classes:"
            find src -path "*/Quality/*" -name "*.cs" -exec basename {} .cs \; | sed 's/^/  - /'
        fi
        
    } > "$quality_report"
    
    log_success "Code quality report saved to $quality_report"
}

# Function to generate defect metrics
generate_defect_metrics() {
    log_info "Generating defect metrics..."
    
    local metrics_file="${OUTPUT_DIR}/defect_metrics_$(date +%Y%m%d_%H%M%S).json"
    
    # Create a sample metrics report (in practice, this would integrate with the DefectTracker)
    cat > "$metrics_file" << EOF
{
  "report_date": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "defect_summary": {
    "total_defects": 0,
    "open_defects": 0,
    "in_progress_defects": 0,
    "testing_defects": 0,
    "closed_defects": 0
  },
  "severity_breakdown": {
    "critical": 0,
    "high": 0,
    "medium": 0,
    "low": 0
  },
  "resolution_metrics": {
    "average_resolution_time_hours": 0,
    "closure_rate_percentage": 0,
    "high_priority_rate_percentage": 0
  },
  "trends": {
    "defects_created_last_week": 0,
    "defects_resolved_last_week": 0,
    "resolution_time_trend": "stable"
  },
  "notes": "This is a template report. Actual metrics would be populated by DefectTracker integration."
}
EOF
    
    log_success "Defect metrics report saved to $metrics_file"
}

# Function to detect potential issues in codebase
detect_potential_issues() {
    log_info "Detecting potential issues..."
    
    local issues_file="${OUTPUT_DIR}/potential_issues_$(date +%Y%m%d_%H%M%S).txt"
    
    {
        echo "Potential Issues Detection Report"
        echo "Generated: $(date)"
        echo "================================="
        echo
        
        # Look for TODO/FIXME comments
        echo "TODO/FIXME Comments:"
        echo "--------------------"
        if grep -r -n -E "(TODO|FIXME|HACK|XXX)" src/ tests/ 2>/dev/null || echo "No TODO/FIXME comments found"; then
            echo
        fi
        
        # Look for exception handling patterns
        echo "Exception Handling Analysis:"
        echo "----------------------------"
        local catch_blocks=$(grep -r -c "catch\s*(" src/ 2>/dev/null | grep -v ":0" | wc -l)
        local throw_statements=$(grep -r -c "throw\s" src/ 2>/dev/null | grep -v ":0" | wc -l)
        echo "Files with catch blocks: $catch_blocks"
        echo "Files with throw statements: $throw_statements"
        echo
        
        # Look for logging usage
        echo "Logging Analysis:"
        echo "-----------------"
        local logging_files=$(grep -r -l "Log\(" src/ 2>/dev/null | wc -l)
        echo "Files using logging: $logging_files"
        echo
        
        # Check for test coverage indicators
        echo "Test Coverage Indicators:"
        echo "-------------------------"
        local test_classes=$(grep -r -l "\[Fact\]" tests/ 2>/dev/null | wc -l)
        local theory_tests=$(grep -r -c "\[Theory\]" tests/ 2>/dev/null | awk -F: '{sum += $2} END {print sum+0}')
        echo "Test classes: $test_classes"
        echo "Theory tests: $theory_tests"
        
    } > "$issues_file"
    
    log_success "Potential issues report saved to $issues_file"
}

# Function to generate summary report
generate_summary_report() {
    log_info "Generating summary report..."
    
    local summary_file="${OUTPUT_DIR}/defect_analysis_summary_$(date +%Y%m%d_%H%M%S).md"
    
    cat > "$summary_file" << EOF
# Defect Analysis Summary Report

**Generated:** $(date)  
**Project:** MSP430 Emulator  
**Analysis Tool:** defect-analysis script

## Executive Summary

This report provides an analysis of defect management infrastructure and code quality metrics for the MSP430 Emulator project.

## Key Findings

### Defect Management Infrastructure
- ✅ DefectTracker class implemented with severity classification
- ✅ Comprehensive test coverage for defect management
- ✅ GitHub issue templates for bug reporting and triage
- ✅ Documentation for classification, triage, and resolution processes

### Code Quality Metrics
$(if [[ -f "${OUTPUT_DIR}"/code_quality_*.txt ]]; then
    echo "- Code analysis completed (see detailed report)"
else
    echo "- Code analysis skipped"
fi)

### Test Coverage
$(if [[ -f "${OUTPUT_DIR}"/test_results_*.xml ]]; then
    echo "- Test execution completed (see detailed report)"
else
    echo "- Test execution skipped"
fi)

### GitHub Integration
$(if [[ -n "${GITHUB_TOKEN}" ]]; then
    echo "- GitHub issues analysis completed"
else
    echo "- GitHub issues analysis skipped (no token provided)"
fi)

## Recommendations

1. **Implement DefectTracker Integration**: Connect the DefectTracker class with GitHub Issues API for automated metrics collection
2. **Set up Automated Reporting**: Schedule regular execution of this analysis script
3. **Enhance Metrics Collection**: Add more detailed performance and quality metrics
4. **Integrate with CI/CD**: Include defect analysis in the continuous integration pipeline

## Files Generated

$(ls -la "${OUTPUT_DIR}"/ | grep "$(date +%Y%m%d)" | awk '{print "- " $9}')

## Next Steps

1. Review detailed reports in the \`${OUTPUT_DIR}\` directory
2. Address any critical issues identified
3. Set up automated defect detection rules
4. Implement dashboard for real-time metrics

EOF

    log_success "Summary report saved to $summary_file"
}

# Main execution flow
main() {
    echo "======================================"
    echo "MSP430 Emulator Defect Analysis"
    echo "======================================"
    echo
    
    # Check dependencies
    if ! command -v jq &> /dev/null; then
        log_warning "jq not found. Some GitHub analysis features will be limited."
    fi
    
    # Run analysis steps
    analyze_github_issues
    analyze_test_results
    analyze_code_quality
    generate_defect_metrics
    detect_potential_issues
    generate_summary_report
    
    echo
    log_success "Defect analysis completed!"
    echo "Reports saved to: $OUTPUT_DIR"
    echo
    echo "To view the summary report:"
    echo "  cat ${OUTPUT_DIR}/defect_analysis_summary_*.md"
}

# Handle command line arguments
case "${1:-}" in
    --help|-h)
        echo "Usage: $0 [options]"
        echo
        echo "Options:"
        echo "  --help, -h     Show this help message"
        echo "  --github-only  Only run GitHub analysis"
        echo "  --local-only   Only run local analysis (skip GitHub)"
        echo
        echo "Environment variables:"
        echo "  GITHUB_TOKEN   GitHub API token for issue analysis"
        echo
        exit 0
        ;;
    --github-only)
        analyze_github_issues
        ;;
    --local-only)
        analyze_test_results
        analyze_code_quality
        generate_defect_metrics
        detect_potential_issues
        generate_summary_report
        ;;
    "")
        main
        ;;
    *)
        log_error "Unknown option: $1"
        echo "Use --help for usage information."
        exit 1
        ;;
esac